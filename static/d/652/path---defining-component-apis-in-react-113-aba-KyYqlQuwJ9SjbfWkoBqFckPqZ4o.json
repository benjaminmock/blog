{"data":{"mdx":{"id":"1f158b48-39fb-500d-a670-bc195d614740","frontmatter":{"title":"Defining Component APIs in React","date":"July 08, 2018","draft":null},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Defining Component APIs in React\",\n  \"date\": \"2018-07-08T00:00:00.000Z\",\n  \"excerpt\": \"Over the years, I’ve noticed patterns in how I tend to approach component APIs and building out applications and libraries. The following is a collection of thoughts, opinions, and advice for defining component APIs that are meant to be more flexible, composable, and easier to understand. None of these are hard-and-fast rules, but they’ve helped guide the way I think about organizing and creating components.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components\n  }), mdx(\"p\", null, \"Over the years, I\\u2019ve noticed patterns in how I tend to approach component APIs and building out applications and libraries.\\nThe following is a collection of thoughts, opinions, and advice for defining component APIs that are meant to be more flexible, composable, and easier to understand.\\nNone of these are hard-and-fast rules, but they\\u2019ve helped guide the way I think about organizing and creating components.\"), mdx(\"h2\", {\n    \"id\": \"aim-for-a-small-api-surface-area\"\n  }, \"Aim for a small API surface area\"), mdx(\"p\", null, \"Just as the React library itself aims for a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=4anAwXYqLG8\"\n  }), \"Minimal API Surface Area\"), \",\\nI recommend adopting a similar mindset when it comes to defining component APIs.\\nThe fewer new things you need to learn, the easier it is for others to know how to use the components\\nthat you create, making them more reusable.\\nIf someone doesn\\u2019t understand your component API, the chance that they\\u2019ll duplicate your work increases.\\nThis idea is at the core of how I approach creating components, and I find it helpful to keep in mind as I work.\"), mdx(\"h2\", {\n    \"id\": \"make-things-easy-to-find\"\n  }, \"Make things easy to find\"), mdx(\"p\", null, \"Start with a flat directory structure and don\\u2019t prematurely organize your code base.\\nHumans love to organize things, but we\\u2019re also really terrible at it.\\nNaming things is hard enough, and by creating a directory structure around your component library,\\nyou might end up doing more work that makes it more difficult for others to find the things you\\u2019ve done.\"), mdx(\"p\", null, \"A single directory of components can get quite large before it becomes difficult for people to manage.\\nAnd if all the components are in a single folder,\\nyou\\u2019ll get alphabetical ordering for free in most file-system tools,\\nwhich can help provide a more complete picture of the code base for others.\"), mdx(\"h2\", {\n    \"id\": \"avoid-renderthing-methods\"\n  }, \"Avoid renderThing methods\"), mdx(\"p\", null, \"If you\\u2019ve defined a custom method in your component that starts with the word \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render\"), \",\\nchances are that should be its own component.\\nAs \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://mobile.twitter.com/chrisbiscardi/status/1004559213320814592\"\n  }), \"Chris Biscardi\"), \" puts it, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\u201C\", \"[It]\", \" effectively means there\\u2019s enough complexity to be worth breaking down\\u201D\"), \".\\nReact\\u2019s smart about when to render or not render a component,\\nso by splitting these out into their own components, you can help React do its job better.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"// Instead of this\\nclass Items extends React.Component {\\n  renderItems ({ items }) {\\n    return items.map(item => (\\n      <li key={item.id}>\\n        {renderItem(item)}\\n      </li>\\n    ))\\n  }\\n\\n  renderItem (item) {\\n    return (\\n      <div>\\n        {item.name}\\n      </div>\\n    )\\n  }\\n\\n  render () {\\n    return (\\n      <ul>\\n        {renderItems(this.props)\\n      </ul>\\n    )\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"// Do this\\nconst ItemList = ({ items }) =>\\n  <ul>\\n    {items.map(item => (\\n      <li key={item.id}>\\n        <Item {...item} />\\n      </li>\\n    )}\\n  </ul>\\n\\nconst Item = ({ name }) =>\\n  <div>{item.name}</div>\\n\\nclass Items extends React.Component {\\n  render () {\\n    const { items } = this.props\\n    return <ItemList items={items} />\\n  }\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"split-components-at-data-boundaries\"\n  }, \"Split components at data boundaries\"), mdx(\"p\", null, \"Often, components should be defined by the shape of your data.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Since you\\u2019re often displaying a JSON data model to a user, you\\u2019ll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely.\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u2013 \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://facebook.github.io/react/docs/thinking-in-react.html\"\n  }), \"Thinking in React\"))), mdx(\"p\", null, \"I often see people new to React attempt to replicate what I call \\\"\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://getbootstrap.com\"\n  }), \"Bootstrap\"), \"\\\" components,\\nthat is UI components that have a visual boundary that\\u2019s not directly tied to any data structure.\\nReact and BEM-like CSS-based components have different concerns.\\nInstead of creating a generic Card component that displays an image, heading, and link,\\nand that would require a custom props API, build components for the data that you\\u2019re displaying.\\nMaybe the generic Card component should be a ProductCard component that can accept the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"product\"), \" object from your database.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"// Instead of this\\n<Card\\n  image={product.thumbnail}\\n  title={product.name}\\n  text={product.description}\\n  link={product.permalink}\\n/>\\n\\n// Do this\\n<ProductCard {...product} />\\n\")), mdx(\"p\", null, \"Chances are, the specific styling that you need for the ProductCard isn\\u2019t all that reusable,\\nand you\\u2019ll likely only have this defined in one place in your code base.\\nYou can follow the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)\"\n  }), \"Rule of Three\"), \" in situations like this.\\nIf you've duplicated the exact Card component structure three times in your code base,\\nthen it\\u2019s probably worth abstracting it out into its own component.\"), mdx(\"h2\", {\n    \"id\": \"avoid-apropcalypse\"\n  }, \"Avoid Apropcalypse\"), mdx(\"p\", null, \"As \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://twitter.com/gurlcode\"\n  }), \"Jenn Creighton\"), \" calls it, avoid \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://speakerdeck.com/jenncreighton/flexible-architecture-for-react-components?slide=10\"\n  }), \"Apropcalypse\"), \".\\nDon\\u2019t be afraid to create a new component rather than adding abritrary props and additional logic to a component.\\nFor example, a Button component might accept props for different colors, sizes, and shapes,\\nbut there\\u2019s not always a need to have every combination of those props available.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"// Instead of this\\n<Button\\n  variant='secondary'\\n  size='large'\\n  outline\\n  label='Buy Now'\\n  icon='shoppingBag'\\n  onClick={handleClick}\\n/>\\n\\n// Do this\\n<SecondaryButton\\n  size='large'\\n  onClick={handleClick}>\\n  <Icon name='shoppingBag' />\\n  Buy Now\\n</SecondaryButton>\\n\")), mdx(\"p\", null, \"Your needs may vary, but reducing the number of custom props that any component requires is generally helpful,\\nand reducing the amount of logic in the render function can make the code base simpler and better-suited for code splitting.\"), mdx(\"h2\", {\n    \"id\": \"use-composition\"\n  }, \"Use composition\"), mdx(\"p\", null, \"Don\\u2019t reinvent \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props.children\"), \".\\nIf you\\u2019ve defined props that take arbitrary strings of text that aren\\u2019t based on a data structure,\\nit\\u2019s probably better to use composition.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"// Instead of this\\n<Header\\n  title='Hello'\\n  subhead='This is a header'\\n  text='And it has arbitrary props'\\n/>\\n\\n// Do this\\n<Header>\\n  <Heading>Hello</Heading>\\n  <Subhead>This is a header</Subhead>\\n  <Text>And it uses composition</Text>\\n</Header>\\n\")), mdx(\"p\", null, \"If you know React, you\\u2019ll already know the API for the composed version, and it shouldn\\u2019t require as much documentation as the former.\\nYou might wrap the composed version into another component that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"is\"), \" tied to a piece of data in your application,\\nbut you\\u2019ll probably only need that component structure defined once in your code base.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"// This makes sense as a component since it\\u2019s based on data\\nconst PageHeader = ({\\n  title,\\n  description\\n}) =>\\n  <Header>\\n    <Heading>{title}</Heading>\\n    <Text>{description}</Text>\\n  </Header>\\n\\n// And ideally can be used like this\\n<PageHeader {...page} />\\n\")), mdx(\"h2\", {\n    \"id\": \"avoid-boolean-props-for-enums\"\n  }, \"Avoid boolean props for enums\"), mdx(\"p\", null, \"It might be tempting to use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://mobile.twitter.com/satya164/status/1015206655997472768\"\n  }), \"boolean props\"), \" as a convenient way to switch between variants of a component,\\nbut it can sometimes create a confusing API.\"), mdx(\"p\", null, \"Take the following example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"<Button primary />\\n<Button secondary />\\n\")), mdx(\"p\", null, \"What happens in the following case?\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"<Button primary secondary />\\n\")), mdx(\"p\", null, \"It\\u2019s impossible to know without diving into the code base or documentation.\\nInstead, try the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"<Button variant='primary' />\\n\")), mdx(\"p\", null, \"It\\u2019s a little more typing but arguably much more readable.\"), mdx(\"h2\", {\n    \"id\": \"keep-props-apis-parallel\"\n  }, \"Keep props APIs parallel\"), mdx(\"p\", null, \"Whenever possible, resuse props from other components. For example, if you\\u2019re creating a date picker, use the same props that the native \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<input type='date' />\"), \" expects.\\nIt\\u2019ll be easier to guess how it works and also easier to remember.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"// Instead of this\\n<DatePicker\\n  date={date}\\n  onSelect={handleDateChange}\\n/>\\n\\n// Do this\\n<DatePicker\\n  value={date}\\n  onChange={handleDateChange}\\n/>\\n\")), mdx(\"p\", null, \"The \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://jxnblk.com/styled-system\"\n  }), \"Styled System\"), \" library encourages using a parallel style props API across multiple components.\\nFor example, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"color\"), \" prop works the same for all components included in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://jxnblk.com/rebass\"\n  }), \"Rebass\"), \",\\nwhich ends up having a sort of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"learn once, use anywhere\"), \" effect.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"// example from Rebass\\n<Box color='tomato' />\\n<Heading color='tomato' />\\n\")), mdx(\"h2\", {\n    \"id\": \"ask-your-teammates\"\n  }, \"Ask your teammates\"), mdx(\"p\", null, \"These are just some of my own thoughts on how to define component APIs, and they might not suite your needs.\\nThe best advice I can give is to talk to your teammates, create RFCs and PRs,\\nand try \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://ponyfoo.com/articles/readme-driven-development\"\n  }), \"Readme Driven Development\"), \".\\nWriting React components is easy.\\nCreating a library of components that works well for your team is worth the time and effort to get right.\"));\n}\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"1f158b48-39fb-500d-a670-bc195d614740"}}